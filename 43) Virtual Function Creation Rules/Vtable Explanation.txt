VTABLE
Also Known as Virtual Table
Every class containing atleast one virtual function has its own vtable.
When a class has a virtual function , all its objects have a hidden pointer as a part of thier memory layout
Its called vptr. Might be of 4/8 bytes depending upon system architecture or compiler architecture (can be verified by printing the object using sizeof)
Its of type (void **) pointer to pointer  or like pointer to an array of pointers
Each object points to its own class vtable.
A vtable is a static array of function pointers (storing memory addresses).
Vtables are placed inside the read-only part of the Data Segment 
Vtable contains address of Virtual Functions as well as Destructors 
VTABLE -> Compile Time
vptr -> Runtime

For other classes , the vtable is just copied and written with some changes of address only.
E.g if class A contains some virtual functions and class B has also those virtual functions with different implementations , and more new ones
, then class B's vtable will copy from class A's vtable and do some changes in it.
The Structure remains same , the addresses are changed.

Suppose we have code : (CASE WHERE PARENT HAS VIRTUAL FUNC BUT CHILD DOES NOT ) 

class Parent
{
virtual void fun1(){}
virtual void fun2(){}

};
class Child : public Parent
{
void fun1() override{}
void fun3(){}
};
and in main() we call by Parent *ptr = new Child; ptr->fun1();


Now this creates a table like below :
Parent vtable :
Parent Address :: fun1()
Parent Address :: fun2()

Child vtable :
Child Address :: fun1()
Parent Address :: fun2()

vptr points to the Child vtable
When the function is called , then the program goes to vptr and sees its address and checks child table , and by using memory offset calculations , it finds fun1() from Child class and executes it
vtable is made for parent as it contains virtual functions
vtable is made for child as it contains the functions that override the parent' virtual functions 
Although if it didn't , child would still have vtable due to inheritance (even if not accessible due to private visibility mode)






2) CASE WHERE CHILD HAS VIRTUAL FUNC BUT PARENT DOES NOT
In this case no polymorphism occurs although vtable of child is made , vptr points to this Child table but is inaccessible via the (Parent *)
No vtable for parent

3) CASE WHERE BOTH HAVE VIRTUAL FUNC 
In this case polymorphism occurs and for both classes vtable is made. (similar to first case)

4) CASE WHERE BOTH HAVE NO VIRTUAL FUNC
In this case no polymorphism and no vtables for any class


For Pure Virtual Functions , compiler just places something different at that point as it doesn't leave the addresses null or empty.
It places an error handler there called __cxa_pure_virtual.
E.g a vtable with a pure virtual function might look like :
&__cxa_pure_virtual :: fun1()



