===========AGGREGATION============
When an object of another class is made inside another class as a pointer or reference , then this is called aggregation
The Inner Class object is not dependent on the outer class object as outer class only contains a pointer or a reference. Actual object is either in main as stack / heap or may be totally in heap.
Here the lifetime of object is unbounded to the outer class object.
We can also make array/vector of objects or use a pointer that can point to many objects using new keyword
We say that outer class "HAS A" / "OWS"  the inner class object (Weak Relationship than Composition)
E.g if we have outer class A and inner object as class B then we can make :
1) B *b;  //Like Pointer and Assign it an object (stack or heap obj)
2) B &b; // Like Reference 

The 1st one is referred to as aggregation but if the objects allocation is done at the time of constructor and deallocation at the time of destructor then it is still aggregation but lifetime just like Composition or we can say that here aggregation becomes equivalent to composition

Once the outer class object scope ends , if it was a pointer inside class then its no longer valid and you can't access object using the pointer (for stack based) If it was a reference then you can't use that reference anymore.The Object still exists and you may still use it where it was defined as this object was passed to the outer class for being its object.
If we used dynamically allocated objects then we need to make sure that we delete as well because it creates a memory leak if we don't delete (as object still exists)
The Object's lifetime is independent as , if it was stack based object , it still exists even after the end of outer class object scope. And if it was a dynamically allocated then user may allocate/deallocate using new/delete in other functions (not in constructors/destructors) so that inner object is finished even before the outer class object scope ends.
Passing by reference or pointer , affects the original object
Passing its copy to the reference or pointer does not change the original object.
Don't pass the temporary object to the pointer/reference as this temporary object is destroyed e.g
if we have class A and B then : A( B(100) ) , this B(100) is a temporary object but causes errors later on as this object is gonna be destroyed but the pointer / reference that is pointing to it , will point to invalid memory location.
The Constructor only runs when a new object is created or when the inner object's constructor paramters are passed or when we use the new keyword to make a new object , not when the object is passed to another object. When an object is passed to inner object as paramter then copy constructor is invoked.

(THIS PARAGRAPH INFO IS THE SAME AS COMPOSITION)
===============================================
The Outer class object can only use the inner class' public member functions only. 
Also we can make outer class as a friend for inner class so that it can easily access all the private data members of the inner objects
If we use constructor to initialize the inner class object or use the member initialization list then the constructor for the inner class object must be present in its own class that matches the inner class object paramters.
Similarly there are many more things like when using overloaded << operator then we should have this <<operator as friend function and separately for both classes i.e outer and inner class.
So we need to check out for these things 
For static data members of the inner class , they are shared among all class objects even if that object is composed inside another object 
The order of constructor is that , first inner object constructor runs , then the constructor of outer class and order of destructor is opposite
We usually use composition and aggregation more than the nested class as nested class becomes more complicated and not a good design

Some people mix up composition , aggregation and inheritance .
These should never be mixed with each other.
See some example and some problems as well.